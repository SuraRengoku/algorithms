在code-runner的编译命令里添加framework时，直接添加在编译器名称后面，否则不识别

异或换值：
    input: a=x, b=y;
    step1: a=a^b=x^y;
    step2: b=b^a=y^x^y=x^y^y=x^0=x;
    step3: a=a^b=x^y^x=y^x^x=y^0=y;

Master Formula:    
    满足master公式的算法均可以使用以下规则求解时间复杂度
    master formula:T(N)=a*T(N/b)+O(N^d)
    其中a是子项数量，T(N/b)是子项规模，O(N^d)是额外时间复杂度

    如果log(b,a)<d，则时间复杂度为O(N^d)
    如果log(b,a)>d，则时间复杂度为O(N^log(b,a))
    如果log(b,a)==d，则时间复杂度为O(N^d*log(2,N))

堆:(完全二叉树结构)
    用数组表示一个完全二叉树，则在下标为i的节点有下列推广：
    左孩子节点下标：2*i+1
    右孩子节点下标：2*i+2
    父节点：(i-1)/2  根节点的父节点还是根节点
    大根堆和小根堆

排序稳定性: 在非基础类型排序中，能否保持同种类型之间数据的相对顺序不变
    不稳定排序: 选择排序，快速排序，堆排序，希尔排序
    稳定排序: 冒泡排序，插入排序，归并排序(小和问题中失去稳定性)

排序改进: 在进行快速排序时，可以在样本量小于60时直接套用插入排序，在调度上使用快速排序，在小样本上使用插入排序极低常数项的优点

哈希表的简单介绍:
1）哈希表在使用层面上可以理解为一种集合结构
2）如果只有key，没有伴随数据value，可以使用Hashset结构(C++中叫UnOrderedset)
3） 如果既有key，又有伴随数据value，可以使用HashMap结构(C++中叫UnOrderedMap)
4） 有无伴随数据，是HashMap和Hashset唯一的区别，底层的实际结构是一回事
5） 使用哈希表增(put）、删(remove）、改(put）和查(get）的操作，可以认为时间复杂度为
0(1），但是常数时间比较大
6）放入哈希表的东西，如果是基础类型，内部按值传递，内存占用就是这个东西的大小
7）放入哈希表的东西，如果不是基础类型，内部按引用传递，内存占用是这个东西内存地
址的大小

有序表的简单介绍:
1）有序表在使用层面上可以理解为一种集合结构
2）如果只有key，没有伴随数据value，可以使用Treeset结构（C++中叫Orderedset)
3） 如果既有key，又有伴随数据value，可以使用TreeMap结构(C++中叫OrderedMap)
4）有无伴随数据，是Treeset 和TreeMap唯一的区别，底层的实际结构是一回事
5）有序表和哈希表的区别是，有序表把key按照顺序组织起来，而哈希表完全不组织
5）红黑树、AVL树、size-balance-tree和跳表等都属于有序表结构，只是底层具体实现
不同
6）放入有序表的东西，如果是基础类型，内部按值传递，内存占用就是这个东西的大小
7）放入有序表的东西，如果不是基础类型，必须提供比较器，内部按引用传递，内存占
用是这个东西内存地址的大小